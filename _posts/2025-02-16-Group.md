---
layout: single
title:  "[백준]SDS"
categories: baekjoon
tags: [Dynamic Programming, baekjoon]
toc: true
author_profile: true
toc_sticky: true
toc_label: 목차
typora-root-url: ../

---



trytty

# string.h 활용법

```c++
char a[100];

scanf(" %s",a);

int n = strlen(a); // "test" 입력
 -> n=4

int comp = strcmp(a, "test");
-> comp = 0 (0이 아니면 다른 것)
```

# comparator 예시

```c++
#include<stdio.h>
#include<algorithm>

using namespace std;

bool comp(const int &a, const int &b)
{
    return a > b;// 내림차순의 경우. 오름차순은 기본값이라 comp함수가 필요 없으나, a < b로 부등호 방향을 바꿔주면 된다.
}

int a[11] = { 0,5,2,4,1,6,8,3,10,7,9 };
int n=10;

int main()
{
    int i;

    for (i = 1; i <= n; i++)
    {
        printf("%d ", a[i]);
    }
    printf("\n");
    sort(a + 1, a + 1 + n, comp);
    for (i = 1; i <= n; i++)
    {
        printf("%d ", a[i]);
    }

    return 0;
}
```

3425번 고스택

```c++
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
#include <algorithm>

int n, top;
long long st[1002];
char cmd[100002][5];
long long nums[100002];

int main()
{
    int i, j;
    for (;;)
    {
        int m;
        for (m = 1;; m++)
        {
            scanf(" %s", cmd[m]);
            if (strcmp(cmd[m], "QUIT") == 0)
            {
                return 0;
            }

            if (strcmp(cmd[m], "END") == 0)
                break;

            if (strcmp(cmd[m], "NUM") == 0)
            {
                scanf("%lld", &nums[m]);
            }
        }
        scanf("%d", &n);
        for (i = 1; i <= n; i++)
        {
            scanf("%lld", &st[0]);
            top = 1;

            bool isError = false;
            for (j = 1; j <= m; j++)
            {
                if (strcmp(cmd[j], "NUM") == 0) {
                    st[top++] = nums[j];
                }
                else if (strcmp(cmd[j], "POP") == 0) {
                    if (top < 1)
                    {
                        isError = true;
                        break;
                    }
                    top--;
                }
                else if (strcmp(cmd[j], "INV") == 0) {
                    if (top < 1)
                    {
                        isError = true;
                        break;
                    }
                    st[top - 1] = -st[top - 1];
                }
                else if (strcmp(cmd[j], "DUP") == 0) {
                    if (top < 1)
                    {
                        isError = true;
                        break;
                    }
                    st[top++] = st[top - 1];
                }
                else if (strcmp(cmd[j], "SWP") == 0) {
                    if (top < 2)
                    {
                        isError = true;
                        break;
                    }
                    std::swap(st[top - 1], st[top - 2]);
                }
                else if (strcmp(cmd[j], "ADD") == 0) {
                    if (top < 2)
                    {
                        isError = true;
                        break;
                    }
                    st[top - 2] += st[top - 1];
                    top--;
                }
                else if (strcmp(cmd[j], "SUB") == 0) {
                    if (top < 2)
                    {
                        isError = true;
                        break;
                    }
                    st[top - 2] -= st[top - 1];
                    top--;
                }
                else if (strcmp(cmd[j], "MUL") == 0) {
                    if (top < 2)
                    {
                        isError = true;
                        break;
                    }
                    st[top - 2] *= st[top - 1];
                    top--;
                }
                else if (strcmp(cmd[j], "DIV") == 0) {
                    if (top < 2 || st[top - 1] == 0)
                    {
                        isError = true;
                        break;
                    }
                    st[top - 2] /= st[top - 1];
                    top--;
                }
                else if (strcmp(cmd[j], "MOD") == 0) {
                    if (top < 2 || st[top - 1] == 0)
                    {
                        isError = true;
                        break;
                    }
                    st[top - 2] %= st[top - 1];
                    top--;
                }
                if (top != 0 && std::abs(st[top - 1]) > 1e9)
                {
                    isError = true;
                    break;
                }
            }
            if (top != 1 || isError)
            {
                printf("ERROR\n");
            }
            else
            {
                printf("%lld\n", st[0]);
            }
        }
        printf("\n");
    }
    return 0;
}
```

# 9663번 nqueen

```c++
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <algorithm>

int n, cnt;
int visitY[17];
int visitR[35];
int visitL[35];

void back(int x)
{
    int i;

    if (x == n + 1)
    {
        cnt++;
        return;
    }

    for (i = 1; i <= n; i++)
    {
        if (visitY[i] == 0 && visitR[x + i] == 0 && visitL[x - i + n] == 0)
        {
            visitY[i] = 1;
            visitR[x + i] = 1;
            visitL[x - i + n] = 1;
            back(x + 1);
            visitY[i] = 0;
            visitR[x + i] = 0;
            visitL[x - i + n] = 0;
        }
    }
}

int main()
{
    scanf("%d", &n);
    back(1);
    printf("%d", cnt);

    return 0;
}
```

# 2003-수들의 합 2 (chos2855)

```c++
#include <iostream>
#include <vector>

using namespace std;

int n, m, N;
int sum = 0;
int cnt = 0;
int L = 0, R = 0;

int main() {

    //N과 M 입력받기
    cin >> n >> m;

    //배열 입력 받기
    vector<int> A(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> A[i];
    }

    while (R <= n) {
        sum += A[R++];
        while (sum > m) { // sum이 m보다 커졌을 때, 작거나 같아질 때가지 L을 증가시켜서 값을 뺀다.
            sum -= A[L++];
        }
        if (sum == m) cnt++;
    }
    cout << cnt;
    return 0;
}
```

### 10828번 스택 (Array 버전)

```c++
// Stack 에서 top 이란 다음 데이터가 추가될 위치를 의미합니다.
// 이를 어레이로 구현할 때에 top은 실제 stack에 쌓여있는 데이터 개수와 동일한 의미를 가집니다.

#include<stdio.h>
#include<string.h>

int stack[10001],top;
int n;

char cmd[10];
int arg;

int main()
{
    int i;
    scanf("%d",&n);

    for(i=1;i<=n;i++)
    {
        scanf(" %s",cmd);

        if(!strcmp(cmd,"push"))
        {
            scanf(" %d",&arg);
            //top위치에 데이터 추가 및 top위치 증가.
            stack[top++] = arg;
        }
        if(!strcmp(cmd,"pop"))
        {
            if(top==0)
            {
                printf("-1\n");
                continue;
            }
            //top-1 위치에서 데이터 추출
            printf("%d\n",stack[--top]);
        }
        if(!strcmp(cmd,"size"))
        {
            printf("%d\n",top);
        }
        if(!strcmp(cmd,"empty"))
        {
            printf("%d\n",top?0:1);
        }
        if(!strcmp(cmd,"top"))
        {
            if(top==0)
            {
                printf("-1\n");
                continue;
            }

            printf("%d\n",stack[top-1]);
        }
    }
    return 0;
}
```

### 10828번 스택 (STL 버전)

```c++
#include<stack>
#include<stdio.h>
#include<string.h>

using namespace std;

int main()
{
    int n,m;
    char tmp[10];
    stack<int> st;
    scanf("%d",&n);
    for(;n--;)
    {
        scanf(" %s",tmp);
        if(strcmp(tmp,"push")==0)
        {
            scanf("%d",&m);
            st.push(m);
        }
        else if(strcmp(tmp,"pop")==0)
        {
            if(st.empty())
            {
                printf("-1\n");
            }
            else 
            {
                printf("%d\n",st.top());
                st.pop();
            }
        }
        else if(strcmp(tmp,"top")==0)
        {
            if(st.empty())
            {
                printf("-1\n");
            }
            else 
            {
                printf("%d\n",st.top());
            }
        }
        else if(strcmp(tmp,"size")==0)
        {
            printf("%d\n",st.size());
        }
        else
        {
            printf("%d\n",st.empty());
        }
    }
    return 0;
}
```

### 10845번 큐 (Array 버전)

```c++
// Queue 에서 front는 데이터를 추출할 위치를, rear는 데이터의 마지막 위치를 이야기 합니다.
// 따라서 데이터가 비어있을때는 rear의 값이 front보다 앞에 올 수 있습니다.
// 본 문제에서는 size를 썼지만, 실질적인 queue의 size는 rear-front+1로 계산됩니다.

#include<stdio.h>
#include<string.h>

int n;

int queue[10001];
int front, rear, size;

char cmd[10];
int arg;

int main()
{
    int i;
    scanf("%d", &n);

    //queue 초기화
    front = 0; rear = -1;

    for (i = 1; i <= n; i++)
    {
        scanf(" %s", cmd);

        if (!strcmp(cmd, "push"))
        {
            scanf(" %d", &arg);
            //rear 다음 위치에 데이터 추가 및 top위치 증가.
            queue[++rear] = arg;
            size++;
        }
        if (!strcmp(cmd, "pop"))
        {
            if (size == 0)
            {
                printf("-1\n");
                continue;
            }

            //front 위치에 원소 추출.
            printf("%d\n", queue[front++]);
            size--;
        }
        if (!strcmp(cmd, "size"))
        {
            printf("%d\n", size);
        }
        if (!strcmp(cmd, "empty"))
        {
            printf("%d\n", size == 0 ? 1 : 0);
        }
        if (!strcmp(cmd, "front"))
        {
            if (size == 0)
            {
                printf("-1\n");
                continue;
            }

            printf("%d\n", queue[front]);
        }
        if (!strcmp(cmd, "back"))
        {
            if (size == 0)
            {
                printf("-1\n");
                continue;
            }

            printf("%d\n", queue[rear]);
        }
    }
    return 0;
}
```

### 10845번 큐 (STL 버전)

```c++
#include<queue>
#include<stdio.h>
#include<string.h>

int n;

std::queue<int> q;

char cmd[10];
int arg;

int main()
{
    int i;
    scanf("%d", &n);

    for (i = 1; i <= n; i++)
    {
        scanf(" %s", cmd);

        if (!strcmp(cmd, "push"))
        {
            scanf(" %d", &arg);

            q.push(arg);
        }
        if (!strcmp(cmd, "pop"))
        {
            if (q.empty())
            {
                printf("-1\n");
                continue;
            }

            printf("%d\n", q.front());
            q.pop();
        }
        if (!strcmp(cmd, "size"))
        {
            printf("%d\n", q.size());
        }
        if (!strcmp(cmd, "empty"))
        {
            printf("%d\n", q.empty() ? 1 : 0);
        }
        if (!strcmp(cmd, "front"))
        {
            if (q.empty())
            {
                printf("-1\n");
                continue;
            }

            printf("%d\n", q.front());
        }
        if (!strcmp(cmd, "back"))
        {
            if (q.empty())
            {
                printf("-1\n");
                continue;
            }

            printf("%d\n", q.back());
        }
    }
    return 0;
}
```

