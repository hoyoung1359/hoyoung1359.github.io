---
layout: single
title:  "[백준]SDS"
categories: baekjoon
tags: [Dynamic Programming, baekjoon]
toc: true
author_profile: true
toc_sticky: true
toc_label: 목차
typora-root-url: ../



---

### 파스칼의 삼각형

```c++
#include<stdio.h>

int dp[1001][1001],n,m;

int main()
{
    int i,j;
    scanf("%d%d",&n,&m);

    dp[0][0]=1;
    for(i=1;i<=n;i++)
    {
        dp[i][0]=1;
        for(j=1;j<=i;j++)
        {
            dp[i][j] = dp[i-1][j-1]+dp[i-1][j];
            dp[i][j]%=10007;
        }
    }

    printf("%d",dp[n][m]);
    return 0;
}


#include<stdio.h>

int n, m;

int d[1001][1001];

int combination(int n, int k)
{
    if (k == 0 || n == k)return 1;
    if (d[n][k] != 0) return d[n][k];
    return d[n][k] = (combination(n - 1, k) + combination(n - 1, k - 1)) % 10007;
}

int main()
{
    scanf("%d%d", &n, &m);
    return 0;
}
```

### 인접 리스트 sample code

```c++
#include<vector>
#include<stdio.h>

using namespace std;

int n, m;
int a, b;
//만약 가중치가 들어간다?
// vector<pair<int,int> > adjlist[320001];
vector<int> adjlist[32001];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
    {
        scanf("%d%d", &a, &b);
        // 방향성이 있는 그래프 a->b
        adjlist[a].push_back(b);
        // if 방향성이 없는 그래프. a->b b->a
        // adjlist[a].push_back(b);
        // adjlist[b].push_back(a);
    }

    for (int i = 1; i <= n; i++)
    {
        // indegree가 0인 정점 x
        int x=3;
        for (int j = 0; j < adjlist[x].size(); j++)
        {
            int y = adjlist[x][j];
        }
        for (int y : adjlist[x])
        {

        }
    }
    return 0;
}
```

### 1922번 네트워크 연결 (크루스칼 구현 예시)

```c++
pair 버전
#include<vector>
#include<stdio.h>
#include<algorithm>

using namespace std;

typedef pair<int,int> pii;
typedef pair<int,pii> pipii;

int n,m;
int uni[1001];
pipii edge[100001];

int get_parent(int x)
{
    if(x==uni[x])return x;
    return uni[x]=get_parent(uni[x]);
}

int main()
{
    int i,a,b,c;
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        edge[i]={c,{a,b}};
    }

    for(i=1;i<=n;i++)
    {
        uni[i]=i;
    }

    int ans = 0;
    sort(edge+1,edge+m+1);
    for(i=1;i<=m;i++)
    {
        a = get_parent(edge[i].second.first);
        b = get_parent(edge[i].second.second);
        if(a!=b)
        {
            ans += edge[i].first;
            uni[a]=b;
        }
    }

    printf("%d",ans);
    return 0;
}


struct 버전
#include<stdio.h>
#include<algorithm>

using namespace std;

struct Edge{
    int dist;
    int x,y;
    bool operator < (const Edge a)const{
        return dist < a.dist;
    }
}data[100001];

int n,m;
int uni[100001];

int getParent(int x)
{
    if(x==uni[x])return x;
    return uni[x]=getParent(uni[x]);
}

int main()
{
    scanf("%d%d",&n,&m);
    int i;
    for(i=1;i<=m;i++)
    {
        scanf("%d%d%d",&data[i].x,&data[i].y,&data[i].dist);
    }
    for(i=1;i<=n;i++)uni[i]=i;
    sort(data+1,data+m+1);
    int ans = 0;
    for(i=1;i<=m;i++)
    {
        int x = getParent(data[i].x);
        int y = getParent(data[i].y);
        if(x!=y)
        {
            ans +=data[i].dist;
            uni[x]=y;
        }
    }

    printf("%d",ans);
    return 0;
}
```

### 3830번 교수님은 기다리지 않는다.

```c++
#include<stdio.h>
#include<algorithm>

using namespace std;

int n, m;
int uni[100001];
int dist[100001];

int getParent(int x)
{
    if (uni[x] == x) return x;

    int pa = getParent(uni[x]);
    // uni[x] 업데이트 하기 전에, dist먼저 업데이트
    dist[x] += dist[uni[x]];
    return uni[x] = pa;
}

int main()
{
    int i, j;
    for (;;)
    {
        scanf("%d%d", &n, &m);
        if (n == 0 && m == 0)
            break;

        for (i = 1; i <= n; i++)
        {
            uni[i] = i;
            dist[i] = 0;
        }

        char c;
        for (i = 1; i <= m; i++)
        {
            scanf(" %c", &c);
            int a, b, w;
            if (c == '!')
            {
                scanf("%d%d%d", &a, &b, &w);

                int pa = getParent(a);
                int pb = getParent(b);
                uni[pb] = pa;
                dist[pb] = w - dist[b] + dist[a];
            }
            else
            {
                scanf("%d%d", &a, &b);

                int pa = getParent(a);
                int pb = getParent(b);

                if (pa == pb)
                    printf("%d\n", dist[b] - dist[a]);
                else
                    printf("UNKNOWN\n");
            }
        }
    }
    return 0;
}
```

### 11438번 LCA2

```c++
#include<vector>
#include<stdio.h>
#include<algorithm>

using namespace std;

int n, m;
vector<int> mp[100001];
int depth[100001];
int parent[18][100001];

void dfs(int x, int d, int p)
{
    depth[x] = d;
    parent[0][x] = p;

    for (int next : mp[x])
    {
        if (next == p) continue;

        dfs(next, d + 1, x);
    }
}

int getLCA(int a, int b)
{
    //1. 둘의 높이를 맞춰줘야한다.
    // a 의 depth가 더 커서 b로 맞춰준다.
    if (depth[a] < depth[b]){
        swap(a, b);
    }

    int i;
    for (i = 17; i >= 0; i--)
    {
        if (depth[a] - depth[b] >= (1 << i))
            a = parent[i][a];
    }

    if (a == b) return a;

    // 2. 조상으로 올라가면서 찾아가야해요.
    for (i = 17; i >= 0; i--)
    {
        if (parent[i][a] == parent[i][b]) continue;
        else
        {
            a = parent[i][a];
            b = parent[i][b];
        }
    }

    return parent[0][a];
}

int main()
{
    int i, j;
    int a, b;
    scanf("%d", &n);
    for (i = 1; i < n; i++)
    {
        scanf("%d%d", &a, &b);
        mp[a].push_back(b);
        mp[b].push_back(a);
    }

    // 1번 노드부터 시작해서 각 노드의 깊이와 parent를 구한다.
    dfs(1, 0, 0);

    for (i = 1; i <= 17; i++)
    {
        for (j = 1; j <= n; j++)
        {
            parent[i][j] = parent[i - 1][parent[i - 1][j]];
        }
    }

    scanf("%d", &m);

    for (i = 1; i <= m; i++)
    {
        scanf("%d%d", &a, &b);

        int lca = getLCA(a, b);

        printf("%d\n", lca);
    }

    return 0;
}
```

### 1753 최단경로 (dijkstra 구현 예시)

```c++
#include<queue>
#include<vector>
#include<stdio.h>
#include<algorithm>
#include<functional>

using namespace std;

typedef pair<int, int> pii;

int n, m, k;
vector<pii> mp[20001];
int dist[20001];
int visit[20001];
priority_queue<pii, vector<pii>, greater<pii> > pq;

int main()
{
    int i;
    scanf("%d%d%d", &n, &m, &k);

    int a, b, c;
    for (i = 1; i <= m; i++)
    {
        scanf("%d%d%d", &a, &b, &c);
        mp[a].push_back({ b,c });
    }

    for (i = 1; i <= n; i++)
    {
        dist[i] = 1e9;
    }
    dist[k] = 0;
    pq.push({ 0,k });

    while (!pq.empty())
    {
        pii p = pq.top(); pq.pop();

        int x = p.second;
        if (visit[x] == 1) continue;

        visit[x] = 1;

        for (pii edge : mp[x])
        {
            int node = edge.first;
            int cost = edge.second;
            if (dist[node] > dist[x] + cost)
            {
                dist[node] = dist[x] + cost;
                pq.push({ dist[node], node});
            }
        }
    }

    for (i = 1; i <= n; i++)
    {
        if (dist[i] == 1e9)
            printf("INF\n");
        else
            printf("%d\n", dist[i]);
    }

    return 0;
}
```

### 14003번 가장 긴 증가하는 부분 수열 5 (LIS Indexed tree 구현 코드)

```c++
#include<stdio.h>
#include<algorithm>

using namespace std;

int n, nn;
int idx[2100000];
int path[1000001];
int dp[1000001];
int a[1000001];
pair<int, int> st[1000001];

int get_max(int l, int r)
{
    l += nn - 1;
    r += nn - 1;

    int mx = 0;
    while (l <= r)
    {
        if (l & 1)mx = max(mx, idx[l++]);
        if (~r & 1)mx = max(mx, idx[r--]);

        l >>= 1;
        r >>= 1;
    }

    return mx;
}

void edit(int i, int v)
{
    i += nn - 1;
    idx[i] = v;
    i >>= 1;
    while (i)
    {
        idx[i] = max(idx[i * 2], idx[i * 2 + 1]);
        i >>= 1;
    }
}

int main()
{
    int i;
    scanf("%d", &n);
    for (i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
        // a[i] 를 기준으로 오름차순 정렬. a[i]가 같다면 i기준 내림차순 정렬
        st[i] = { a[i],-i };
    }

    ////기존 방식////
    /*
    int j, k;
    for (i = 1; i <= n; i++)
    { 
        k = 0;
        for (j = 1; j < i; j++)
        {
            if (a[j] < a[i])
                k = max(k, dp[j]);
        }

        dp[i] = k + 1;
    }
    */ 
    /////////////////

    //index tree 셋팅 (초기화는 필요 x)
    for (nn = 1; nn < n; nn *= 2);

    // 정렬
    sort(st + 1, st + n + 1);

    int mx = 0, x;
    for (i = 1; i <= n; i++)
    {
        // i번째 데이터의 index
        x = -st[i].second;
        // dp[x] = 1 ~ x-1 구간의 최댓값 +1
        dp[x] = get_max(1, x - 1) + 1;
        // dp값을 index tree에 업데이트
        edit(x, dp[x]);

        // 최댓값 저장
        mx = max(dp[x], mx);
    }

    printf("%d\n", mx);
    int mxx = mx;
    int inf = 1e9;
    for (i = n; i >= 1; i--)
    {
        if (dp[i] == mxx && a[i] < inf)
        {
            path[mxx] = i;
            inf = a[i];
            mxx--;
        }
    }

    for (i = 1; i <= mx; i++)
        printf("%d ", a[path[i]]);
    return 0;
}
```

### 9252번 LCS 2 (DP 역추적)

```c++
#include<iostream>
#include<stdio.h>
#include<string>
#include<string.h>
#include<algorithm>

using namespace std;

int n,m;
char a[1001], b[1001];
int dp[1001][1001];

char ans[1001];

int main()
{
    scanf("%s %s", a + 1, b + 1);
    n = strlen(a + 1);
    m = strlen(b + 1);

    /*
    cin >> a >> b;
    a = '_' + a;
    b = '_' + b;
    */

    int i, j;
    for (i = 1; i <= n; i++)
    {
        for (j = 1; j <= m; j++)
        {
            if (a[i] == b[j])
            {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            }
            else
            {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    int cnt = 0;
    i = n; j = m;
    while (i > 0 && j > 0)
    {
        if (a[i] == b[j])
        {
            ans[cnt++] = a[i];
            i--; j--;
        }
        else if (dp[i][j - 1] == dp[i][j])
        {
            j--;
        }
        else
            i--;
    }
    for (i = cnt - 1; i >= 0; i--)
    {
        printf("%c", ans[i]);
    }

    return 0;
}
```

### 2098번 외판원 순회 (bitmask 구현 예시)

```c++
#include<stdio.h>
#include<algorithm>

using namespace std;

int dp[66000][17];
int n;
int mp[17][17];

int main()
{
    int i, j, k;

    scanf("%d", &n);
    for (i = 1; i <= n; i++)
        for (j = 1; j <= n; j++)
            scanf("%d", &mp[i][j]);

    for (i = 0; i <= (1 << n); i++)
    {
        for (j = 1; j <= n; j++)
            dp[i][j] = 1e9;
    }

    dp[1][1] = 0;

    for (i = 2; i < (1 << n); i++)
    {
        for (j = 1; j <= n; j++)
        {
            if (i &(1 << (j - 1)))
            {
                int v = i - (1 << (j - 1));
                for (k = 1; k <= n; k++)
                {
                    if (mp[k][j] == 0)continue;
                    dp[i][j] = min(dp[i][j], dp[v][k] + mp[k][j]);
                }
            }
        }
    }

    int mn = 1e9;
    int v = (1 << n) - 1;
    for (i = 2; i <= n; i++)
    {
        if (mp[i][1] == 0)continue;
        mn = min(mn, dp[v][i] + mp[i][1]);
    }

    printf("%d", mn);

    return 0;
}
```

### 11266번 단절점 (구현 예시)

```c++
#include<vector>
#include<stdio.h>
#include<algorithm>

using namespace std;

int n,m;
vector<int> mp[10001];
int dist[10001],dd;
int cut[10001];

int dfs(int node,bool r)
{
    dist[node]=++dd;
    int rtn = dd;
    int child=0;
    for(int p : mp[node])
    {
        if(dist[p]==0)
        {
            child++;
            int child_low = dfs(p,0);
            if(!r&&child_low>=dist[node])
            {
                cut[node]=1;
            }
            rtn = min(rtn,child_low);
        }
        else
            rtn = min(rtn,dist[p]);
    }
    if(r&&child>1)
    {
        cut[node]=1;
    }
    return rtn;
}

int main()
{
    int i,j,x,y;
    scanf("%d%d",&n,&m);

    for(i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        mp[x].push_back(y);
        mp[y].push_back(x);
    }

    for(i=1;i<=n;i++)
        if(dist[i]==0)
            dfs(i,true);
    int ans = 0;
    for(i=1;i<=n;i++)
    {
        ans+=cut[i];
    }
    printf("%d\n",ans);
    for(i=1;i<=n;i++){
        if(cut[i])printf("%d ",i);
    }
    return 0;
}
```

