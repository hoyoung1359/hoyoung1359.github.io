---
layout: single
title:  "[백준]SDS"
categories: baekjoon
tags: [Dynamic Programming, baekjoon]
toc: true
author_profile: true
toc_sticky: true
toc_label: 목차
typora-root-url: ../


---

### 1991번 트리 순회

```c++
#include<stdio.h>

int n;
int child[27][3];
char a,b,c;

void preorder(int node)
{
    if(node==0)return;
    printf("%c",node+'A'-1);
    preorder(child[node][0]);
    preorder(child[node][1]);
}

void inorder(int node)
{
    if(node==0)return;
    inorder(child[node][0]);
    printf("%c",node+'A'-1);
    inorder(child[node][1]);
}

void postorder(int node)
{
    if(node==0)return;
    postorder(child[node][0]);
    postorder(child[node][1]);
    printf("%c",node+'A'-1);
}

int main()
{
    scanf("%d",&n);
    int i;
    for(i=1;i<=n;i++)
    {
        scanf(" %c %c %c",&a,&b,&c);
        if(b!='.')
            child[a-'A'+1][0]=b-'A'+1;
        if(c!='.')
            child[a-'A'+1][1]=c-'A'+1;
    }

    preorder(1);
    puts("");
    inorder(1);
    puts("");
    postorder(1);

    return 0;
}
```

### 1920번 수찾기

```c++
#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>
#include<algorithm>

int n, m;
int a[100002], b[100002];

int main()
{
    int i;
    scanf("%d", &n);
    for (i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
    }
    scanf("%d", &m);
    for (i = 1; i <= m; i++)
    {
        scanf("%d", &b[i]);
    }

    std::sort(a + 1, a + n + 1);
    int l, r, mid=0;
    for (i = 1; i <= m; i++)
    {
        l = 1, r = n;
        bool exist = false;
        while (l <= r)
        {
            mid = (l + r) / 2;

            if (a[mid] > b[i])
            {
                r = mid - 1;
            }
            else if (a[mid] < b[i])
            {
                l = mid + 1;
            }
            else
            {
                exist=true;
                break;
            }
        }
        if (exist)
        {
            printf("1\n");
        }
        else
        {
            printf("0\n");
        }
    }
    return 0;
}
```

### 1927번 최소 힙

```c++
#include <stdio.h>

int n;
int heap[263000];
int hsize;

int main()
{
    int i;
    scanf("%d", &n);
    int x;
    for (i = 1; i <= n; i++)
    {
        scanf("%d", &x);
        if (x == 0) // heap 에서 삭제
        {
            int output = heap[1];

            heap[1] = heap[hsize--];
            int node = 1;
            while (node <= hsize)
            {
                    //index 체크 필수!
                int lnode = node * 2;
                int rnode = node * 2 + 1;
                if (heap[lnode] < heap[node] && heap[lnode] <= heap[rnode])
                {
                    swap(heap[lnode], heap[node]);
                    node = lnode;
                }
                else if (heap[rnode] < heap[node] && heap[rnode] < heap[lnode])
                {
                    swap(heap[rnode], heap[node]);
                    node = rnode;
                }
                else break;
            }
        }
        else // heap 에 x를 추가
        {
            heap[++hsize] = x;
            int node = hsize;
            while (node != 1 && heap[node] < heap[node / 2])
            {
                swap(heap[node], heap[node / 2]);
                node /= 2;
            }
        }
    }
    return 0;
}
```

### 1927번 최소 힙 (STL) + pair

```c++
#include <queue>
#include <vector>
#include <stdio.h>
#include <functional>

using namespace std;

struct compare
{
    bool operator()(const int &a, const int &b) {
        return a > b;
    }
};
typedef pair<int, int> pii;
pair<int, int> p;
int n;
priority_queue<int, vector<int>, compare> q;
// 기본 max heap
// priority_queue<int> q;
// 기본 min heap
 priority_queue<pii, vector<pii>, greater<pii> > q;

int main()
{
    p.first;
    p.second;
    p = { 1,2 };
    int i;
    scanf("%d", &n);
    int x;
    for (i = 1; i <= n; i++)
    {
        scanf("%d", &x);
        if (x == 0) // heap 에서 삭제
        {
            if (q.empty())
            {
                printf("0\n");
            }
            else {
                int out = q.top(); q.pop();
                printf("%d\n", out);
            }
        }
        else // heap 에 x를 추가
        {
            q.push(x);
        }
    }
    return 0;
}
```

### 2042번 구간 합 구하기

```c++
#include <stdio.h>

int n, m, k;
long long idx[2100000];
long long data[1000001];
int leaf;

int main()
{
    int i;
    scanf("%d%d%d", &n, &m, &k);

    for (leaf = 1; leaf < n; leaf *= 2);

    for (i = 0; i < n; i++)
    {
        scanf("%lld", &data[i]);
        idx[leaf + i] = data[i];
    }

    for (i = leaf - 1; i >= 1; i--)
    {
        idx[i] = idx[i * 2] + idx[i * 2 + 1];
    }

    int a, b;
    long long c;
    for (i = 1; i <= m + k; i++)
    {
        scanf("%d%d%lld", &a, &b, &c);

        if (a == 1)
        {
            b += leaf - 1;
            idx[b] = c;
            b /= 2;
            while (b >= 1)
            {
                idx[b] = idx[b * 2] + idx[b * 2 + 1];
                b /= 2;
            }
        }
        else
        {
            b += leaf - 1;
            c += leaf - 1;

            long long sum = 0;
            while (b <= c)
            {
                if (b % 2 == 1) sum += idx[b++];
                if (c % 2 == 0) sum += idx[c--];

                b /= 2;
                c /= 2;
            }
            printf("%lld\n", sum);
        }
    }

    return 0;
}
```

### trie 자료구조 예시 (5052번)

```c++
#include<stdio.h>

struct Trie{
    bool check;
    Trie* tr[10];

    Trie(){
        check=false;
        for(int i=0;i<10;i++)
            tr[i] = nullptr;
    }
    ~Trie(){
        for(int i=0;i<10;i++)
            if(tr[i]) delete tr[i];
    }
    bool insert(char *t){
        if(check==true) return false;
        if(!*(t))
        {
            check = true;
            for(int i=0;i<10;i++)
                if(tr[i]!=nullptr)
                    return false;
            return true;
        }
        if(tr[*t-'0']==nullptr)
            tr[*t-'0'] = new Trie();
        return tr[*t-'0']->insert(t+1);
    }
}*tr;

int n;
char phone[12];

int main()
{
    int t;
    scanf("%d",&t);

    for(int tt=1;tt<=t;tt++)
    {
        scanf("%d",&n);

        tr = new Trie();

        bool ans = true;
        for(int i=1;i<=n;i++)
        {
            scanf("%s",phone);
            if(ans){
                bool tf = tr->insert(phone);
                ans&=tf;
            }
        }

        delete tr;

        puts(ans?"YES":"NO");
    }
    return 0;
}
```

### 확장 유클리드 호제법 (3955번)

```c++
#include <stdio.h>

struct RET{
    long long x,y,g;
    RET(long long xx, long long yy, long long gg)
    {
        x = xx;
        y = yy;
        g = gg;
    };
};

long long X,K,C,Ans;

RET exgcd(long long a, long long b)
{
    // xa + by = gcd(a,b)
    if(b == 0) return RET(1,0,a); // 1*a + 0*b = a = gcd(a,b)
    long long q = a/b; // a * 1 + b * (-q) = a%b
    RET tmp = exgcd(b,a%b); // b * tmp.x + a%b * tmp.y = gcd(a,b)
    RET ret = RET(tmp.y,tmp.x-tmp.y*q,tmp.g); // a * ret.x + b * ret.y = gcd(a,b)
    return ret;     
}

long long gcd(long long a, long long b)
{
    if(b>0) return gcd(b,a%b);
    else return a;
}

RET eegcd(long long a, long long b)
{

    long long s1 = 1, s2 = 0, s3 = 0;
    long long t1 = 0, t2 = 1, t3 = 1;
    long long r1 = a, r2 = b, r3 = b, q;
    long long g = gcd(a,b) ;

    while(r3 > g)
    {
        q = r1/r2;
        r3 = r1%r2;
        s3 = s1 - q*s2;
        t3 = t1 - q*t2;
        s1 = s2; s2 = s3;
        t1 = t2; t2 = t3;
        r1 = r2;
        r2 = r3;
    }
    return RET(s3,t3,g);

}

int main()
{
    int T;scanf("%d",&T);
    while(T--)
    {
        scanf("%lld%lld",&K,&C);

        RET ret = eegcd(K,C);
        if(ret.g != 1) printf("IMPOSSIBLE\n");
        else 
        {
            long long ans = ret.y , ans2 = ret.x;
            while(ans <= 0||ans2 >=0) 
            {
                ans += K;
                ans2 -= C;
            }
            if(ans > 1000000000L) printf("IMPOSSIBLE\n");
            else printf("%lld\n",ans);
        }
    }
}
```

### 2960번 에라토스테네스의 체

```c++
#include<stdio.h>

int n,k,cnt;
int data[1001];

int main()
{
    int i,j;
    scanf("%d%d",&n,&k);

    for(i=2;i<=n;i++)
    {
        if(data[i]==0)
        {
            cnt++;
            if(cnt==k)
            {
                printf("%d",i);
                return 0;
            }
            for(j=i*i;j<=n;j+=i)
            {
                if(data[j]==0)
                {
                    cnt++;
                    if(cnt==k)
                    {
                        printf("%d",j);
                        return 0;
                    }
                    data[j]=1;
                }
            }
        }
    }
    return 0;
}
```

### 소수 구하기

```c++
#include<stdio.h>

int n, k;
int p[1001];

int main()
{
    int i, j;
    scanf("%d%d", &n, &k);
    // n이 소수인지 판별하기 위해서는 root n까지만 보면 된다.
    for (i = 2; i * i <= n; i++)
    {
        if (p[i] == 0)
        {
            for (j = i * i; j <= n; j += i)
            {
                p[j] = 1;
            }
        }
    }

    vector<int> prime;
    for (i = 2; i <= n; i++)
    {
        if (p[i] == 0)prime.push_back(i);
    }
    return 0;
}
```

