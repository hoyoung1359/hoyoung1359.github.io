---
layout: single
title: "[운영체제/OS] 2-1.  프로세스(Processses)"
categories: OS
tags: [운영체제, OS, Computer Science, Process, PCB]
toc: true
author_profile: true
toc_sticky: true
toc_label: 목차
typora-root-url: ../
---

## 1. 프로세스의 개념

> 💡 **면접 대비**: 프로세스의 정의와 구성 요소는 OS 관련 기술 면접에서 매우 자주 등장하는 핵심 질문입니다.

### 1.1 프로세스란?
- **정의**: 실행 중인 프로그램의 인스턴스
- **구성 요소**:
  1. **이미지(Images)**
     - 코드(Code): 기계어 명령어
     - 데이터(Data): 변수들
     - 스택(Stack): 함수 호출 상태
     - 힙(Heap): 동적 메모리
  2. **프로세스 문맥(Process Context)**

[이미지 필요: 프로세스의 구성 요소를 도식화한 다이어그램]

### 1.2 프로세스 문맥(Context)
1. **프로그램 문맥**
   - 데이터 레지스터
   - 프로그램 카운터
   - 스택 포인터

2. **커널 문맥**
   - pid, gid, sid
   - 환경 변수
   - VM 구조(페이징 테이블)
   - 열린 파일들
   - 시그널 핸들러

## 2. 프로세스 메모리 구조

### 2.1 메모리 세그먼트
> 💡 **면접 대비**: 프로세스의 메모리 구조는 메모리 관리와 관련된 면접 질문에서 필수적인 내용입니다.

1. **코드 세그먼트 (Text Segment)**
   - 실행 코드가 저장
   - 일반적으로 읽기 전용

2. **데이터 세그먼트**
   - 초기화된 데이터 영역
   - 초기화되지 않은 데이터 영역 (BSS)
     - 커널이 프로그램 시작 전 0으로 초기화

3. **스택 세그먼트**
   - 자동 변수
   - 임시 변수
   - 반환 주소
   - 호출자의 환경

4. **힙 세그먼트**
   - 동적으로 할당된 메모리

[이미지 필요: C 프로그램의 메모리 레이아웃 다이어그램]

### 2.2 메모리 레이아웃 예제
```c
long array[100];
long bufsize = 100;

int main(void) {
    int i;
    char* buf;
    i = 10;
    buf = f1(i);
    return(0);
}

char* f1(int n) {
    printf("%d\n", i);
    return malloc(bufsize);
}
```

## 3. 프로세스 제어 구조

### 3.1 프로세스 제어 블록 (PCB)
> 💡 **면접 대비**: PCB는 프로세스 관리의 핵심 자료구조로, OS 면접에서 자주 다루어지는 주제입니다.

- **정의**: 프로세스와 관련된 정보를 저장하는 커널의 핵심 자료구조
- **특징**: 모든 프로세스마다 하나씩 존재
- **구성 요소**:
  1. 이미지 정보
  2. 프로세스 문맥
     - 프로그램 문맥
     - 커널 문맥

[이미지 필요: PCB 구조 다이어그램]

## 4. OS의 데이터 구조

### 4.1 시스템 테이블
1. **메모리 데이터 구조**
   - 프로세스별 메모리 할당 정보
   - 가상 메모리 관리 정보
   - 공유 메모리 영역의 보호 속성

2. **파일 데이터 구조**
   - 파일 존재 여부
   - 보조 기억장치상의 위치
   - 현재 상태
   - 속성 정보

3. **I/O 데이터 구조**
   - I/O 장치 가용성
   - I/O 작업 상태
   - 메모리 전송 위치

4. **프로세스 데이터 구조 (PCB)**
   - 프로세스 위치
   - 프로세스 관리 속성
     - 프로세스 ID
     - 프로세스 상태
     - 메모리 위치 등

## 5. 프로세스 상태

### 5.1 5단계 프로세스 상태 모델
> 💡 **면접 대비**: 프로세스 상태와 상태 전이는 OS 동작 이해의 기본이 되는 매우 중요한 개념입니다.

1. **생성 (new)**
   - 프로세스가 생성되는 중

2. **준비 (ready)**
   - 프로세서 할당을 기다리는 상태

3. **실행 (running)**
   - 명령어들이 실행되는 상태

4. **대기 (blocked/waiting)**
   - I/O 완료 등의 이벤트를 기다리는 상태

5. **종료 (exit/terminated)**
   - 실행이 완료된 상태

[이미지 필요: 프로세스 상태 다이어그램]

## 6. 프로세스 스케줄링
> 💡 **참고**: 자세한 내용은 Lecture 5에서 다룰 예정입니다.

### 6.1 스케줄링 종류
1. **장기 스케줄링 (Job Scheduling)**
   - 시스템에 진입할 프로세스 선택
   - 다중 프로그래밍 정도 조절
   - 호출 빈도 낮음 (초, 분 단위)

2. **단기 스케줄링 (CPU Scheduling)**
   - 실행할 프로세스 선택
   - CPU 할당
   - 매우 빈번히 호출 (밀리초 단위)

3. **중기 스케줄링 (Medium Term Scheduling)**

[이미지 필요: 스케줄링 단계별 다이어그램]

## 7. 프로세스 전환

### 7.1 모드 전환 vs 프로세스 전환
> 💡 **면접 대비**: 모드 전환과 프로세스 전환의 차이점은 면접에서 자주 물어보는 질문입니다.

1. **모드 전환 발생 조건**
   - 외부 인터럽트 (타이머, I/O)
   - 내부 트랩 (예외)
   - 시스템 콜

2. **프로세스 전환 단계**
   - 프로그램 문맥 저장
   - 현재 프로세스 상태 업데이트
   - PCB를 적절한 큐로 이동
   - 새로운 프로세스 선택
   - 선택된 프로세스의 상태 업데이트
   - 메모리 관리 구조 업데이트
   - 프로그램 문맥 복원

### 7.2 전환 오버헤드
- 전환 중에는 유용한 작업 수행 불가
- 운영체제가 복잡할수록 전환 작업량 증가
- 효율적인 전환을 위한 하드웨어 지원
  - 예: Sun UltraSPARC의 다중 레지스터 세트

[이미지 필요: 프로세스 전환 과정 다이어그램]

## 참고 자료
- A. Silberschatz의 운영체제 개론
- Operating System Concepts (10th Edition)