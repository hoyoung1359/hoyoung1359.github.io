---
layout: single
title:  "[백준] 1920번 수찾기 (C++)"
categories: baekjoon
tags: [백준, 자료구조, 정렬, 이분탐색]
toc: true
author_profile: true
toc_sticky: true
toc_label: 목차
typora-root-url: ../


---

# [문제](https://www.acmicpc.net/problem/1920)  

**N**개의 정수 **A[1], A[2], …, A[N]**이 주어져 있을 때,  
이 안에 **X**라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.  

# 입력  

첫째 줄에 자연수 **N**(1 ≤ N ≤ 100,000)이 주어진다.  
다음 줄에는 **N**개의 정수 **A[1], A[2], …, A[N]**이 주어진다.   
다음 줄에는 **M**(1 ≤ M ≤ 100,000)이 주어진다.  
다음 줄에는 **M**개의 수들이 주어지는데, 이 수들이 **A**안에 존재하는지 알아내면 된다.   
모든 정수의 범위는 -2³¹ 보다 크거나 같고 2³¹보다 작다. 

## 예제 입력1

```
5
4 1 5 2 3
5
1 3 7 9 5
```

​     

# 출력  

M개의 줄에 답을 출력한다. 존재하면 1을, 존재하지 않으면 0을 출력한다.

## 예제 출력 1  

```
1
1
0
0
1 
```

​              

# 풀이

## 문제 해결 방법

이 문제는 주어진 배열에서 특정 수가 존재하는지를 확인하는 문제입니다. 이를 효율적으로 해결하기 위해 이분 탐색을 사용합니다. 이분 탐색은 정렬된 배열에서 특정 값을 찾는 데 매우 효과적입니다. 다음은 문제를 해결하는 단계입니다:

1. **입력 받기**: 먼저, 배열 A와 찾고자 하는 수들이 담긴 배열 B를 입력받습니다.

2. **정렬**: 이분 탐색을 사용하기 위해 배열 A를 오름차순으로 정렬합니다. 이는 `std::sort` 함수를 사용하여 간단히 수행할 수 있습니다.

3. **이분 탐색 수행**: 배열 B의 각 원소에 대해 배열 A에서 해당 원소가 존재하는지를 이분 탐색을 통해 확인합니다. 이분 탐색은 다음과 같이 수행됩니다:
   - 배열 A의 중간 값을 선택합니다.
   - 중간 값이 찾고자 하는 값보다 크면, 오른쪽 절반을 버리고 왼쪽 절반에서 탐색을 계속합니다.
   - 중간 값이 찾고자 하는 값보다 작으면, 왼쪽 절반을 버리고 오른쪽 절반에서 탐색을 계속합니다.
   - 중간 값이 찾고자 하는 값과 같으면, 해당 값이 존재함을 확인할 수 있습니다.

4. **결과 출력**: 배열 B의 각 원소에 대해 배열 A에 존재하면 1을, 존재하지 않으면 0을 출력합니다.

이와 같은 방법으로 문제를 효율적으로 해결할 수 있습니다. 이분 탐색의 시간 복잡도는 O(log N)이므로, 전체 알고리즘의 시간 복잡도는 **O(N log N + M log N)**입니다.  
이는 N과 M이 최대 100,000일 때도 충분히 빠르게 동작합니다.  

## 코드

```c++
#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>
#include<algorithm>

int n, m;
int a[100002], b[100002];

int main()
{
    int i;
    scanf("%d", &n);
    for (i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
    }
    scanf("%d", &m);
    for (i = 1; i <= m; i++)
    {
        scanf("%d", &b[i]);
    }

    std::sort(a + 1, a + n + 1);
    int l, r, mid=0;
    for (i = 1; i <= m; i++)
    {
        l = 1, r = n;
        bool exist = false;
        while (l <= r)
        {
            mid = (l + r) / 2;

            if (a[mid] > b[i])
            {
                r = mid - 1;
            }
            else if (a[mid] < b[i])
            {
                l = mid + 1;
            }
            else
            {
                exist=true;
                break;
            }
        }
        if (exist)
        {
            printf("1\n");
        }
        else
        {
            printf("0\n");
        }
    }
    return 0;
}
```
