---
layout: single
title:  "[알고리즘 특강] 6. Graph"
categories: algorithm
tags: [SWEA, C++, Graph, Dijkstra]
toc: true
author_profile: true
---


그래프 & 다익스트라  

# 그래프 구현  

그래프를 구현하는 방법은 인접 행렬과 인접 리스트가 있다.  
아래의 그래프를 다양한 방법의 인접 리스트로 구현해보고 각자의 장단점을 알아보자.

![그래프_1](/assets/images/2024-09-20-6_Graph/그래프_1.png)

정점의 개수는 n, 간선의 정보는 단방향 간선을 std::pair로 담은 std::vector로 주어진다고 하겠다.  

```c++
#include <vector>

using namespace std;

constexpr int n = 5;
const vector<pair<int, int>> edges = { {0,1}, {0,2}, {0,3}, {1,2}, {1,4}, {3,2}, {4,3} }
```

# 인접 리스트 구현 -  std::vector  

구현량이 적어서 많이 쓰이는 방식이다.  
어떤 정점과 인접한 모든 정점을 std::vector같은 동적 배열에 저장한다  

| u    | graph[u] |
| ---- | -------- |
| 0    | 1  2  3  |
| 1    | 2  4     |
| 2    |          |
| 3    | 2        |
| 4    | 3        |

```c++
#include <vector>

using namespace std;

struct LinkedListNode {
    int id;
    int next;
};
```

장점  
구현이 매우 쉽다  
간선으로 이어진 정점 정보가 하나의 배열에 담기므로, 배열에서 할 수 있는 모든 작업 (정렬, 삭제 등)을 자유롭게 할 수 있다.  

단점  
std::vector에 정점을 push하는데 오버헤드가 생긴다.  
여러개의 테스트케이스를 처리할 경우, 메모리에 빈 공간이 많이 생긴다.  
메모리상에 각각의 배열이 파편화되어 저장되므로 캐시 효율이 떨어진다.  

# 인접 리스트 구현 - 링크드 리스트





